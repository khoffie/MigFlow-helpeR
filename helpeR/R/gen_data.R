##' Generates FlowDatagermans.csv and districts.csv.
##'
##' @param dist_type character, centroid or pos. If centroid, (xcoord,
##'     ycoord) are the coordinates of the centroid. If pos, (xcoord,
##'     ycoord) are generated by sf::st_point_on_surface. Distances in
##'     flow data are distances between centroids or point_on_surface
##'     respectively.
##' @param year_min integer minimum year to use
##' @param year_max integer, maximum year to use
##' @return NULL
##' @import data.table
##' @import sf
##' @export gen_data
##' @author Konstantin
gen_data <- function(year_min, year_max, dist_type = c("centroid", "pos")) {
    . <- region <- bl_ags <- NULL
    type <- match.arg(dist_type)
    
    p_raw <- "./data/raw"
    p_clean <- "./data/clean"
    flows <- fread(file.path(p_clean, "flows_districts_2000_2017_ger.csv"))
    age_for <- read_age(file.path(p_clean, "germanpop.csv"))
    shp <- setDT(sf::read_sf(file.path(p_clean, "/shapes/districts_ext.shp")))
    density <- data.table::fread(file.path(p_clean, "density.csv"))[
                             , .(region, year, density, bl_ags)]
    correct <- data.table::fread(file.path(p_clean, "correct.csv"))

    flows <- clean_flows(flows, correct, age_for, year_min, year_max)
    districts <- gen_coords_dt(shp, age_for, density, type = type)
    check_tables(flows, districts)
    calculate_distances(flows, districts)
    check_codes(flows, districts)
    fwrite(flows, "./data/FlowDataGermans.csv")
    fwrite(districts, "./data/districts.csv")

    message("Data written to disk.")
}

read_age <- function(file) {
    dt <- fread(file)
    data.table::setnames(dt, "age_group", "agegroup")
    helpeR::rec_ages(dt)
    return(dt)
}

clean_flows <- function(flows, correct, age_dt, year_min, year_max) {
    age_group <- . <- origin <- destination <- flow <- fromdist <- NULL
    todist <- frompop <- i.german <- region <- topop <- agegroup <- NULL

    ## in correct_flows we remove year == 2001 and origin %in% c(3201, 3253)
    flows <- correct_flows(flows, correct)
    
    flows <- flows[year >= year_min & year <= year_max & age_group != "all", 
               .(fromdist = origin, todist = destination, year,
                 agegroup = age_group, flows = flow)]
    rec_ages(flows)
    flows <- add_missing_flows(flows, flows[, unique(fromdist)],
                               flows[, unique(agegroup)], flows[, unique(year)])
    ### omitting since all intra-district flows are 0 and this would be
    ### hard to explain for the model
    flows <- flows[fromdist != todist]
    flows <- flows[order(fromdist, todist, year, agegroup)]
    
    flows[age_dt, frompop := i.german, on = .(fromdist = region, year, agegroup)]
    flows[age_dt, topop := i.german, on = .(todist = region, year, agegroup)]
    return(flows)
}

gen_coords <- function(dt, type) {
    pos <- geometry <- xcoord <- ycoord <- NULL
        if(type == "centroid") {
        dt[, pos := sf::st_centroid(geometry)]
    }
    if(type == "pos") {
        dt[, pos := sf::st_point_on_surface(geometry)]
    }
    dt[, xcoord := st_coordinates(pos)[, 1] / 1e3]
    dt[, ycoord := st_coordinates(pos)[, 2] / 1e3]
    return(dt)
}

gen_coords_dt <- function(shp, age_dt, density_dt, type) {
    . <- AGS <- GEN <- xcoord <- ycoord <- bl_name <- bl_ags <- density <- NULL
    i.density <- region <- agegroup <- pop <- i.german <- distcode <- name <- NULL

    shp[, year := 2017] ## actual year is 2018, hacky but otherwise join fails
    gen_coords(shp, type = type)
    dt <- shp[, .(distcode = AGS, year, name = GEN, 
                         xcoord, ycoord,
                         bl_name, bl_ags)]

    dt[density_dt, density := i.density, on = .(distcode = region, year)]
    dt[age_dt[agegroup == "all", ], pop := i.german, on = .(distcode = region, year)]
    dt <- dt[, .(distcode, year, pop, density, name, xcoord, ycoord, bl_ags, bl_name)]
    return(dt)
}

check_tables <- function(flows, coords) {
    fromdist <- todist <- distcode <- . <- name <- xcoord <- ycoord <- NULL

    stopifnot(all(flows[, unique(fromdist)] == flows[order(todist), unique(todist)] ))
    stopifnot(all(flows[, unique(fromdist)] == coords[, distcode]))
    coords[distcode %in% c(5315, 2000, 11000, 14713, 9162, 1001),
              .(name, xcoord = xcoord, ycoord = ycoord)]
    coords[, .(min = min(xcoord), max = max(xcoord))]
    coords[, .(min = min(ycoord), max = max(ycoord))]
}

calculate_distances <- function(flows, coords) {
    distcode <- . <- xcoord <- ycoord <- distance <- NULL
    x_from <- x_to <- y_from <- y_to <- dist <- i.distance <- fromdist <- todist <- NULL
    
    regions  <- coords[, unique(distcode)]
    distances <- CJ(fromdist = regions, todist = regions)
    distances[coords, c("x_from", "y_from") := .(xcoord, ycoord), on = .(fromdist = distcode)]
    distances[coords, c("x_to", "y_to") := .(xcoord, ycoord), on = .(todist = distcode)]
    distances[, distance := sqrt((x_from - x_to)^2 + (y_from - y_to)^2)]
    flows[distances, dist := as.integer(round(i.distance)), on = .(fromdist, todist)]
    return(NULL)
}

check_codes <- function(f, d) {
    test <- f[, .(equal = setequal(unique(fromdist), d[year == .BY$year, distcode])),
               keyby = .(year, agegroup)]
##    on.exit(return(test))
    if(any(test[, ! equal])) {
        stop("District codes not matched across tables")
    } else {
        message("District codes matched across tables for all years.")
    }
}

## pop_weighted_distance <- function(districts, municipalities_path, inkar_path) {
##     gen_munis <- function() {
##         munis <- setDT(sf::read_sf(municipalities_file))[year == 2017]
##         ink <- fread(inkar_file)
##         setnames(ink, c("Kennziffer", "Zeitbezug"), c("region", "year"))
##         munis_pop <- helpeR::create_design_mat(ink, 425, "Gemeinden", 2017)
##         munis_pop[X425 == 0.1, X425 := 0] ## because create_design_mat sets them to 0.1
##         munis[, distcode := as.integer(substr(AGS, 1, 5))]
##         munis[, region := as.integer(AGS)]
##         munis[munis_pop, pop := i.X425, on = .(region)]
##         gen_coords(munis)
##         munis[, pop_dist := sum(pop, na.rm = TRUE), keyby = .(distcode)]
##         munis <- munis[, .(municode = region, distcode, pop, pop_dist, xcoord, ycoord)]
##         munis <- munis[!is.na(pop)]
##         return(munis)
##     }

##     gen_dist_muni_dt <- function(munis) {
##         distances <- data.table::CJ(fromdist = districts[, distcode], todist = districts[, distcode])
##         distances <- distances[fromdist != todist]
##         cols <- setdiff(colnames(munis), "distcode")
##         distances <- distances[munis, on = .(fromdist = distcode), allow.cartesian = TRUE]
##         setnames(distances, cols, paste0("from_", cols))
##         distances <- distances[munis, on = .(todist = distcode), allow.cartesian = TRUE]
##         setnames(distances, cols, paste0("to_", cols))
##         return(distances)
##     }

##     calc_weighted_distance <- function(dt) {
##          dt[, distance := sqrt((from_xcoord - to_xcoord)^2 + (from_ycoord - to_ycoord)^2)]
##          dt[, fromweights := from_pop / from_pop_dist]
##          dt[, toweights := to_pop / to_pop_dist]
##          dt <- dt[, .(distance_w = sum(distance * fromweights * toweights)), keyby = .(fromdist, todist)]
##          return(dt)
##     }
##     munis <- gen_munis()
##     distances <- gen_dist_muni_dt(munis)
##     distances <- calc_weighted_distance(distances)
##     return(distances)
## }


## distances <- pop_weighted_distance(districts,
##                                    "~/Diss/inst/extdata/clean/shapes/munis_all.shp",
##                                    "~/Diss/inst/extdata/clean/inkar/inkar_2021.csv")
## flows[distances, dist_w := i.distance_w, on = .(fromdist, todist)]
