##' Generates FlowDatagermans.csv and districts.csv.
##' @param outpath character, directory to save FlowDataGermans.csv
##'   and districts.csv.
##' @param dist_type character, centroid or pos. If centroid, (xcoord,
##'   ycoord) are the coordinates of the centroid. If pos, (xcoord,
##'   ycoord) are generated by sf::st_point_on_surface. Distances in
##'   flow data are distances between centroids or point_on_surface
##'   respectively.
##' @param topop_type character, which population for topop:
##'   Population of age group or total population?
##' @param year_min integer minimum year to use
##' @param year_max integer, maximum year to use
##' @return NULL
##' @import data.table
##' @import sf
##' @export gen_data
##' @author Konstantin
gen_data <- function(outpath, year_min, year_max,
                     dist_type = c("centroid", "pos"),
                     topop_type = c("agegroup", "all")) {
  . <- region <- bl_ags <- NULL
  dist_type <- match.arg(dist_type)
  topop_type <- match.arg(topop_type)

  dir.create(outpath, showWarnings = FALSE)

  p_raw <- "./data/raw"
  p_clean <- "./data/clean"
  flows <- fread(file.path(p_clean, "flows_districts_2000_2017_ger.csv"))
  germanpop <- fread(file.path(p_clean, "germanpop.csv"))
  shp <- setDT(sf::read_sf(file.path(p_clean, "/shapes/districts_ext.shp")))
  density <- data.table::fread(file.path(p_clean, "density.csv"))[
                         , .(region, year, density, bl_ags)]
  correct <- data.table::fread(file.path(p_clean, "correct.csv"))

  flows <- clean_flows(flows, correct, germanpop, year_min, year_max, topop_type)
  flows <- replace_lateresettlers(flows)
  districts <- gen_districts(density, germanpop, shp, year_min, year_max,
                             dist_type = dist_type)

  check_tables(flows, districts)
  calculate_distances(flows, districts)
  check_codes(flows, districts)
  fwrite(flows, file.path(outpath, "FlowDataGermans.csv"))
  fwrite(districts, file.path(outpath, "districts.csv"))
  message("Data written to disk.")
}

clean_flows <- function(flows, correct, age_dt, year_min, year_max, topop_type) {
  age_group <- . <- origin <- destination <- flow <- fromdist <- NULL
  todist <- frompop <- i.german <- region <- topop <- agegroup <- i.all <- NULL
  ## in correct_flows we remove year == 2001 and origin %in% c(3201, 3253)
  flows <- correct_flows(flows, correct)

  flows <- flows[year >= year_min & year <= year_max & age_group != "all",
                 .(fromdist = origin, todist = destination, year,
                   agegroup = age_group, flows = flow)]
  rec_ages(flows)
  flows <- add_missing_flows(flows, flows[, unique(fromdist)],
                             flows[, unique(agegroup)], flows[, unique(year)])

### omitting since all intra-district flows are 0 and this would be
### hard to explain for the model
  flows <- flows[fromdist != todist]
  flows <- flows[order(fromdist, todist, year, agegroup)]

  flows[age_dt, frompop := i.german, on = .(fromdist = region, year, agegroup)]
  if(topop_type == "agegroup") {
    flows[age_dt, topop := i.all,
          on = .(todist = region, year, agegroup)]
    message("Topop: Population in age group")
  }
  if(topop_type == "all") {
    flows[age_dt[agegroup == "all"], topop := i.all,
          on = .(todist = region, year)]
    message("Topop: Total population")
  }
  return(flows)
}

gen_coords <- function(dt, type) {
  pos <- geometry <- xcoord <- ycoord <- NULL
  if(type == "centroid") {
    dt[, pos := sf::st_centroid(geometry)]
  }
  if(type == "pos") {
    dt[, pos := sf::st_point_on_surface(geometry)]
  }
  dt[, xcoord := st_coordinates(pos)[, 1] / 1e3]
  dt[, ycoord := st_coordinates(pos)[, 2] / 1e3]
  return(dt)
}

gen_districts <- function(density, germanpop, shp, year_min, year_max, dist_type) {
  . <- region <- agegroup <- pop <- i.all <- i.GEN <- i.xcoord <- i.ycoord <- NULL
  i.bl_ags <- i.bl_name <- AGS <- NULL
  dt <- density[, .(distcode = region, year, density)]
  dt[germanpop[agegroup == "all"], pop := i.all, on = .(distcode = region, year)]
  message("District pop: Germans + Foreigners")
  gen_coords(shp, dist_type)
  nc <- c("name", "xcoord", "ycoord", "bl_ags", "bl_name")
  dt[shp, c(nc) := .(i.GEN, i.xcoord, i.ycoord, i.bl_ags, i.bl_name), on = .(distcode = AGS)]
  setcolorder(dt, c("distcode", "year", "pop"))
  dt <- dt[year >= year_min & year <= year_max]
  return(dt)
}

check_tables <- function(flows, coords) {
  fromdist <- todist <- distcode <- . <- name <- xcoord <- ycoord <- NULL

  stopifnot(all(flows[, unique(fromdist)] == flows[order(todist), unique(todist)] ))
  stopifnot(all(flows[, unique(fromdist)] == coords[, unique(distcode)]))
  coords[distcode %in% c(5315, 2000, 11000, 14713, 9162, 1001),
         .(name, xcoord = xcoord, ycoord = ycoord)]
  coords[, .(min = min(xcoord), max = max(xcoord))]
  coords[, .(min = min(ycoord), max = max(ycoord))]
}

calculate_distances <- function(flows, coords) {
  distcode <- . <- xcoord <- ycoord <- distance <- NULL
  x_from <- x_to <- y_from <- y_to <- dist <- i.distance <- fromdist <- todist <- NULL

  regions  <- coords[, unique(distcode)]
  distances <- CJ(fromdist = regions, todist = regions)
  distances[coords, c("x_from", "y_from") := .(xcoord, ycoord), on = .(fromdist = distcode)]
  distances[coords, c("x_to", "y_to") := .(xcoord, ycoord), on = .(todist = distcode)]
  distances[, distance := sqrt((x_from - x_to)^2 + (y_from - y_to)^2)]
  flows[distances, dist := as.integer(round(i.distance)), on = .(fromdist, todist)]
  return(NULL)
}

check_codes <- function(f, d) {
  . <- fromdist <- distcode <- agegroup <- equal <- NULL
  test <- f[, .(equal = setequal(unique(fromdist), d[year == .BY$year, distcode])),
            keyby = .(year, agegroup)]
  ##    on.exit(return(test))
  if(any(test[, ! equal])) {
    stop("District codes not matched across tables")
  } else {
    message("District codes matched across tables for all years.")
  }
}

##' Appends missing rows to flow data
##'
##' Flow data obtained from the federal statistical office only has
##' rows if flows are > 0. add_missing_flows adds rows that are
##' missing and sets flows for those rows to 0.
##' @param flows data.table with flows
##' @param regions character, unique regions
##' @param agegroups character, unique agegroups
##' @param years numeric, unique years
##' @return flow data.table with missing rows
##' @import data.table
##' @export add_missing_flows
##' @author Konstantin Hoffie
add_missing_flows <- function(flows, regions, agegroups, years) {
    ### in flows data all 0 flows are missing. We add them now to make
    ### sure all origins have the same destinations for all age groups and
### vice versa
    all_keys <- data.table::CJ(fromdist = regions,
                   todist = regions,
                   agegroup = agegroups,
                   year = years)
    data.table::setkeyv(all_keys, colnames(all_keys))
    data.table::setkeyv(flows, colnames(all_keys))
    flows <- flows[all_keys]
    flows[is.na(flows), flows := 0]
    return(flows)
}

##' Recodes German agegroups to English
##'
##' @param dt data.table
##' @return NULL
##' @import data.table
##' @export rec_ages
##' @author Konstantin Hoffie
rec_ages <- function(dt) {
  agegroup <- i.new <- . <- old <- NULL
  lbls <- data.table::data.table(old = c("unter18", "\u00fcber65"),
                     new = c("below18", "above65"))
  dt[lbls, agegroup := i.new, on = .(agegroup = old)]
  return(NULL)
}

replace_lateresettlers <- function(dt) {
  fromdist <- year <- NULL
  replace_with_average(dt, 3159, 2000:2005)
  replace_with_average(dt, 3459, 2000)
  replace_with_average(dt, 8237, 2000)
  replace_with_average(dt, 5978, 2000:2005)
  message("Replaced flows related to German late resettlers with average 2007-2009.")
}

replace_with_average <- function(dt, origin, years) {
  fromdist <- flows <- todist <- agegroup <- year <- i.flows <- . <- NULL
  dt2 <- dt[year %in% c(2006, 2007, 2008)]
  dtavg <- dt2[fromdist == origin, .(flows = int(mean(flows))), keyby = .(fromdist, todist, agegroup)]
  dtavg <- dtavg[, .(year = years), by = .(fromdist, todist, agegroup, flows)]
  dt[dtavg, on = .(fromdist, todist, agegroup, year), flows := i.flows]
}

int <- function(x) { as.integer(round(x, 0)) }

## pop_weighted_distance <- function(districts, municipalities_path, inkar_path) {
##     gen_munis <- function() {
##         munis <- setDT(sf::read_sf(municipalities_file))[year == 2017]
##         ink <- fread(inkar_file)
##         setnames(ink, c("Kennziffer", "Zeitbezug"), c("region", "year"))
##         munis_pop <- helpeR::create_design_mat(ink, 425, "Gemeinden", 2017)
##         munis_pop[X425 == 0.1, X425 := 0] ## because create_design_mat sets them to 0.1
##         munis[, distcode := as.integer(substr(AGS, 1, 5))]
##         munis[, region := as.integer(AGS)]
##         munis[munis_pop, pop := i.X425, on = .(region)]
##         gen_coords(munis)
##         munis[, pop_dist := sum(pop, na.rm = TRUE), keyby = .(distcode)]
##         munis <- munis[, .(municode = region, distcode, pop, pop_dist, xcoord, ycoord)]
##         munis <- munis[!is.na(pop)]
##         return(munis)
##     }

##     gen_dist_muni_dt <- function(munis) {
##         distances <- data.table::CJ(fromdist = districts[, distcode], todist = districts[, distcode])
##         distances <- distances[fromdist != todist]
##         cols <- setdiff(colnames(munis), "distcode")
##         distances <- distances[munis, on = .(fromdist = distcode), allow.cartesian = TRUE]
##         setnames(distances, cols, paste0("from_", cols))
##         distances <- distances[munis, on = .(todist = distcode), allow.cartesian = TRUE]
##         setnames(distances, cols, paste0("to_", cols))
##         return(distances)
##     }

##     calc_weighted_distance <- function(dt) {
##          dt[, distance := sqrt((from_xcoord - to_xcoord)^2 + (from_ycoord - to_ycoord)^2)]
##          dt[, fromweights := from_pop / from_pop_dist]
##          dt[, toweights := to_pop / to_pop_dist]
##          dt <- dt[, .(distance_w = sum(distance * fromweights * toweights)), keyby = .(fromdist, todist)]
##          return(dt)
##     }
##     munis <- gen_munis()
##     distances <- gen_dist_muni_dt(munis)
##     distances <- calc_weighted_distance(distances)
##     return(distances)
## }


## distances <- pop_weighted_distance(districts,
##                                    "~/Diss/inst/extdata/clean/shapes/munis_all.shp",
##                                    "~/Diss/inst/extdata/clean/inkar/inkar_2021.csv")
## flows[distances, dist_w := i.distance_w, on = .(fromdist, todist)]
